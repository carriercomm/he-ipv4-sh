#!/bin/bash
######################################################################
# he-ipv4.sh - Updates the IPv4 endpoint for your Hurricane Electric 
# Tunnel Broker.
# 
# Copyright (C) 2011  Tim Heckman <timothy.heckman@gmail.com>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  
# 02110-1301, USA.
######################################################################

######################################################################
# To get this script running on your system place it in 
# /usr/local/sbin
# Then as root run: chmod +x /usr/local/sbin/he-ipv4.sh
# You'll then want to create a job in the root crontab to run this 
# script on a schedule.  It's recommend to run this script no less
# than every 15 minutes.  You may also want it to run immediately 
# after a system reboot.  These two lines, when added to the crontab
# will run the script after reboot and every quarter hour:
# 
# @reboot /usr/sbin/he-ipv4.sh >/dev/null 2>&1
# */15 * * * * /usr/sbin/he-ipv4.sh >/dev/null 2>&1
#
# Note:  This script is designed to run on Debian-derived distros
# with the IPv6 tunnel configured in "/etc/network/interfaces"
######################################################################

######################################################################
# Configuration Section
# Note: Not all of these values are checked for their sanity
# Please check all entries before initiating the script
######################################################################

# Settings from Hurricane Electric Tunnel Broker site
# UserID avalue from the Tunnel Broker "Main Page"
userID=""

# User password hash.  This is generated by issuing the following
# command from a terminal:
# echo -n YourPassword | md5sum
# This entry *must* be hashed
userPass=""

# Tunnel ID from your tunnel information page
tunnelID=""

# Settings for local machine
# Name of IPv6 tunnel interface (as defined in /etc/network/interfaces)
tunnelName="he-ipv6"

# What you want to prefix the log entries with
LOG="(he-ipv4.sh)"

# How much information do you want to log?
# LVL=3 (everything)
# LVL=2 (warnings+errors)
# LVL=1 (errors only)
# LVL=0 (no logging)
LVL=3

# Configures the two URLs to be used to obtain the external IPv4
# address.  I would recommend not changing these unless one stops
# working as expected in the future.
URLA="http://v4.ipv6-test.com/api/myip.php"
URLB="http://automation.whatismyip.com/n09230945.asp"

######################################################################
# End Configuration Section
# Do not modify any lines after this section
######################################################################
# set -x 
######################################################################
# Functions
######################################################################

# Logs information to syslog based on the "LVL" defined above
# Usage in code slock "message here" [log_level]
# Example: slog "Could not obtain external IPv4 address" 1

slog () {
# Checks if logging is enabled
if [ $LVL -ge "1" ]; then
        
	#Sends you to the correct code depending on the [log_level] passed
        case $2 in

                [3])
                	#Checks to see if the logging enabled would log this level
                        if (( "$2" <= "$LVL" )); then
                                LMSG="$LOG [Info] $1"
                                /usr/bin/logger $LMSG
                        fi
                        ;;
                [2])
                        if (( "$2" <= "$LVL" )); then   
                                LMSG="$LOG [Warning] $1"
                                /usr/bin/logger $LMSG
                        fi
                        ;;
                [1])
                        if (( "$2" <= "$LVL" )); then
                                LMSG="$LOG [Error] $1"
                                /usr/bin/logger -s $LMSG
                        fi
                        ;;
                *)
                        ;;
        esac    

# Debug -- Enable to view logged messages on console
# /bin/echo "$LMSG" > /tmp/he-debug

fi
}

# This function simply takes down, and brings back up, the specified interface
# You simply call his function from within the script

reset_tunnel () {
        slog "Killing $tunnelNname interface for ten seconds" 2

        # Takes down IPv6 tunnel
        /sbin/ifdown $tunnelName
        /bin/sleep 10

        # Bringing back IPv6 tunnel
        /sbin/ifup $tunnelName
	/etc/init.d/radvd restart
        slog "$tunnelName and RAdvD have been restarted!" 3
}

######################################################################
# Script
######################################################################

FILE="0"

# Debug Point
# echo "tunnelName $tunnelName"
# echo "userID: $userID"
# echo "userPass: $userPass"
# echo "tunnelID: $tunnelID"
# echo "Log prefix: $LOG"

# Script needs to be ran as root.  This statement verifies this
# If installed properly this should not be an issue, but better to
# double check.
WHOAMI=`/usr/bin/whoami`
if [ $WHOAMI != "root" ]; then

	slog "The IPv4 update script needs to be ran as root, not $WHOAMI.  Exiting" 1
	exit

fi

# Verifies whether /var/cache/he-ipv4.ip exists.  If not, creates it
# If the creation fails this script exits.
# The /var/cache/he-ipv4.ip file caches the last known IPv4 address
if [ ! -f "/var/cache/he-ipv4.ip" ]; then
	
	# Prints information to the sys
	# Implented it this way to make debugging a bit easier
	slog "\"/var/cache/he-ipv4.ip\" does not exist, attempting to create file" 2
	/bin/touch /var/cache/he-ipv4.ip
		
	# Checks whether the file was actually created
	if [ $? == "0" -a -f "/var/cache/he-ipv4.ip" ]; then
		
		slog "\"/var/cache/he-ipv4.ip\" has successfully been created" 3
		# The file variable is used later to determine if the he-ipv4.ip file has any content in it
		# if FILE == 1 then the cache file is new and should not be matched (used later on)
		FILE="1"
	
	else
		
		slog "There was an error creating \"/var/cache/he-ipv4.ip\". The script will now exit" 1
		exit
	
	fi
fi

# Checks to see if /var/cache/he-ipv4.url exists
# If it does not exist the file is then created
# This file is used to rotate the URLs being used
# to obtain the IPv4 address

if [ ! -f "/var/cache/he-ipv4.url" ]; then
	
	# Prints information to the sys
	# Implented it this way to make debugging a bit easier
	slog "\"/var/cache/he-ipv4.url\" does not exist, attempting to create file" 2
	/bin/touch /var/cache/he-ipv4.url
		
	# Checks whether the file was actually created
	if [ $? == "0" -a -f "/var/cache/he-ipv4.url" ]; then
		
		slog "\"/var/cache/he-ipv4.url\" has successfully been created" 3
		echo "1" > /var/cache/he-ipv4.url
	
	else
		
		slog "There was an error creating \"/var/cache/he-ipv4.url\". The script will now exit" 1
		exit
	
	fi
fi

# Selects the URL that is to be used as the primary grab,
# as well as the last resort.
# Changes value of file to rotate URL on next run

read fileURL < /var/cache/he-ipv4.url

if [ $fileURL == "1" ]; then
	
	URL1=$URLA
	URL2=$URLB
	/bin/echo "2" > /var/cache/he-ipv4.url
else
	
	URL1=$URLB
	URL2=$URLA
	/bin/echo "1" > /var/cache/he-ipv4.url
fi

# Regex for determining if the data in IPV4 is indeed an IPV4 address
REGEX="^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"

# Grab the IPv4 address and begin to match that against the file.
IPV4=`/usr/bin/curl -s "$URL1"`
# Debug
# echo "Inital IPv4 grab: $IPV4"

# Validate that IPV4 is indeed an IPv4 address
if [[ ! $IPV4 =~ $REGEX ]]; then
	
	slog "The variable IPV4 does not contain a value that matches a valid IPv4 address. Retrying by using secondary URL in 5 seconds" 2
	
	/bin/sleep 5
	IPV4=`/usr/bin/curl -s "$URL2"`
	
	if [[ ! $IPV4 =~ $REGEX ]]; then
		
		slog "The variable IPV4 does not contain a value that matches a valid IP address after a second attempt. Retrying the primary URL again in 5 seconds" 2
		/bin/sleep 5
		IPV4=`/usr/bin/curl -s "$URL1"`
		
		if [[ ! $IPV4 =~ $REGEX ]]; then
			
			slog "Unable to obtain a valid IPv4 address from multiple sources. The script will now exit" 1

			# Checks to see if the file is new
			if [[ "$FILE" == "1" ]]; then
			
				# This echo line adds some info to the IPv4 cache file so it can be matched against in the future
				/bin/echo "127.0.0.1" > /var/cache/he-ipv4.ip

			fi
			exit
		fi
	fi
fi

#Generates update URL
URL="https://ipv4.tunnelbroker.net/ipv4_end.php?apikey=$userID&pass=$userPass&ip=$IPV4&tid=$tunnelID"

# Match the IPv4 against the cached version - Update the HE tunnel (restart local tunnel) as needed
# If $FILE is "0" then the file is assumed to exist (going by the IF statement at the beginning of
# this script)
if [ $FILE == "0" ]; then
		
	# Reads the cached file and places it in fileIP variable
	read fileIP < /var/cache/he-ipv4.ip
		
	# Validates that the line read is an actual IPv4 address
	if [[ ! $fileIP =~ $REGEX ]]; then
			
		# Not sure this is totally the best idea, but thinking about it for awhile I felt it was best
		# to push the update if the cached file was full of garbage.  Then we'll simply output good information
		# to the cache file for the next time this script runs.
			
		slog "Could not validate that \"/var/cache/he-ipv4.ip\" contained a valid IPv4 address" 2
		slog "Updating IPv4 endpoint address to $IPV4 as well overwriting \"/var/cache/he-ipv4.ip\" with valid data" 2

		# Updates the tunnel with the current IP address
		/usr/bin/curl -k -s "$URL"
		# Debug
		# echo $URL

		# Sends the current IPv4 address to that file overwriting any other data
		/bin/echo $IPV4 > /var/cache/he-ipv4.ip
		
		slog "The IPv4 endpoint address has been updated to $IPV4 as well as saved to \"/var/cache/he-ipv4.ip\"" 3
	
		# Tunnel reset function.  Relies on $tunnelName being assigned in config section
		reset_tunnel
		exit
		
	#Checks to see if the IPV4 addres is the same.  If it is, kill script
	elif [ $fileIP == $IPV4 ]; then
		
		slog "The external IPv4 address ($IPV4) has not changed. Exiting" 3
		exit
	else
			
		# Debug
		# echo "$URL $IPV4"
		/usr/bin/curl -k -s "$URL"
		/bin/echo $IPV4 > /var/cache/he-ipv4.ip
		
		slog "The IPv4 endpoint address has been updated to $IPV4 as well as saved to \"/var/cache/he-ipv4.ip\"" 3
		reset_tunnel
	fi
else 
# The cache file is new and should not be matched against
# Tunnel is just updated and cache file has data put in place

	# Debug
        # echo $URL
       
	/usr/bin/curl -k -s "$URL"
        /bin/echo $IPV4 > /var/cache/he-ipv4.ip

        slog "The IPv4 endpoint address has been updated to $IPV4 as well as saved to \"/var/cache/he-ipv4.ip\"" 3
       	reset_tunnel
fi
/bin/echo ""

